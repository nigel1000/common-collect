## 概述

Linux 内部层级结构，最底层到最上层依次是硬件、内核空间和用户空间。

Linux 提供了**轮询**、**I/O 中断**以及 **DMA 传输**这 3 种磁盘与主存之间的数据传输机制。

1. 轮询方式是基于死循环对 I/O 端口进行不断检测。
2. I/O 中断方式是指当数据到达时，磁盘主动向 CPU 发起中断请求，由 **CPU 自身负责**数据的传输过程。
3. DMA 传输则在 I/O 中断的基础上引入了 DMA 磁盘控制器，由 **DMA 磁盘控制器负责**数据的传输，降低了 I/O 中断操作对 CPU 资源的大量消耗，解放了CPU。

## I/O 中断原理

在 DMA 技术出现之前，应用程序与磁盘之间的 I/O 操作都是通过 CPU 的中断完成的。

每次用户进程读取磁盘数据时，都需要 CPU 中断，然后发起 I/O 请求**等待数据读取**和**拷贝完成**，每次的 I/O 中断都**导致 CPU 的上下文切换**：

1. 用户进程向 CPU 发起 read 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。
2. CPU 在接收到指令以后对磁盘发起 I/O 请求，将**磁盘数据**先放入**磁盘控制器缓冲区**。
3. 数据准备完成以后，磁盘向 CPU 发起 I/O 中断。
4. CPU 收到 I/O 中断以后将**磁盘缓冲区**中的数据拷贝到**内核缓冲区**，然后再从**内核缓冲区**拷贝到**用户缓冲区**。
5. 用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。

![IO中断](../../images/IO%E4%B8%AD%E6%96%AD.jpg)

## DMA 传输原理

DMA 的全称叫直接内存存取（Direct Memory Access），是一种允许**外围设备**（硬件子系统）**直接访问系统主内存**的机制。也就是说，基于 DMA 访问方式，**系统主内存于硬盘或网卡之间的数据传输可以绕开 CPU 的全程调度**。这样在大部分时间里，**CPU 计算和 I/O 操作都处于并行操作**，使整个计算机系统的效率大大提高。

目前大多数的硬件设备，包括磁盘控制器、网卡、显卡以及声卡等都支持 DMA 技术。整个数据传输操作在一个 DMA 控制器的控制下进行的。**CPU 除了在数据传输开始和结束时做一点处理外（开始和结束时候要做中断处理），在传输过程中 CPU 可以继续进行其他的工作。**

1. 用户进程向 CPU 发起 read 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。
2. CPU 在接收到指令以后对 DMA 磁盘控制器发起调度指令。
3. DMA 磁盘控制器对磁盘发起 I/O 请求，将**磁盘数据**先**放入磁盘控制器缓冲区**，**CPU 全程不参与此过程**。
4. 数据读取完成后，DMA 磁盘控制器会接受到磁盘的通知，将数据从**磁盘控制器缓冲区**拷贝到**内核缓冲区**。
5. DMA 磁盘控制器向 CPU 发出数据读完的信号，由 **CPU 负责**将数据从**内核缓冲区**拷贝到**用户缓冲区**。
6. 用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。

![DMA](../../images/DMA%E4%BC%A0%E8%BE%93.jpg)

## 写时复制

在某些情况下，内核缓冲区可能被多个进程所共享，如果某个进程想要这个共享区进行 write 操作，由于 write 不提供任何的锁操作，那么就会对共享区中的数据造成破坏，写时复制的引入就是 Linux 用来保护数据的。

写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么就需要将其拷贝到自己的进程地址空间中。这样做并不影响其他进程对这块数据的操作，每个进程要修改的时候才会进行拷贝，所以叫写时拷贝。

这种方法在某种程度上能够降低系统开销，如果某个进程永远不会对所访问的数据进行更改，那么也就永远不需要拷贝。

